#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = require("path");
const commander_1 = __importDefault(require("commander"));
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const command_1 = require("./command");
const utils_1 = require("./utils");
const child_process_1 = require("child_process");
const strip_json_comments_1 = __importDefault(require("strip-json-comments"));
function runCommands(commands) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const command of commands) {
            console.log('> Running Command');
            command.describe();
            const code = yield command.execute();
            if (code !== 0) {
                throw new Error('Error encountered running last command');
            }
            console.log(`${ansi_colors_1.default.green('DONE')}\n`);
        }
    });
}
function runner(cwd, packagePath, packageJson, tsconfig) {
    if (commander_1.default.postInstall) {
        if (!packageJson.scripts) {
            packageJson.scripts = {};
        }
        let modified = false;
        if (packageJson.scripts['prepublishOnly']) {
            console.log('prepublishOnly already exists, doing nothing');
        }
        else {
            console.log('Adding prepublishOnly to prevent npm-publish');
            packageJson.scripts['prepublishOnly'] = 'echo "Do not run publish directly, run tsc-publish" && exit 1';
            modified = true;
        }
        if (!packageJson.scripts['tsc-publish']) {
            console.log('Adding tsc-publish script');
            packageJson.scripts['tsc-publish'] = 'tsc-publish';
            modified = true;
        }
        if (modified) {
            console.log(`Writing out modified package.json to ${packagePath}`);
            fs_1.default.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2));
        }
        process.exit();
    }
    const commands = [];
    let buildStepFound = false;
    if (packageJson.scripts) {
        if (commander_1.default.checks !== false) { // Find lint action
            for (const script of ['lint', 'tslint', 'eslint', 'tslint:check', 'eslint:check']) {
                if (packageJson.scripts[script]) {
                    commands.push(new command_1.NpmRunCommand(cwd, script));
                    break;
                }
            }
            // Find test action
            for (const script of ['test']) {
                if (packageJson.scripts[script]) {
                    commands.push(new command_1.NpmRunCommand(cwd, script));
                    break;
                }
            }
        }
        // Find build action
        for (const script of ['build', 'build_all', 'compile']) {
            if (packageJson.scripts[script]) {
                commands.push(new command_1.NpmRunCommand(cwd, script));
                buildStepFound = true;
                break;
            }
        }
    }
    if (!buildStepFound) {
        const inDev = packageJson.devDependencies && packageJson.devDependencies['typescript'];
        const inDeps = packageJson.dependencies && packageJson.dependencies['typescript'];
        if (inDev || inDeps) {
            commands.push(new command_1.ExecCommand(cwd, './node_modules/bin/tsc'));
            buildStepFound = true;
        }
    }
    // TODO: check if tsc is installed in path
    if (!buildStepFound) {
        throw new Error('No build step found');
    }
    const files = utils_1.getNonSrcFiles(cwd, (tsconfig && tsconfig.compilerOptions) ? tsconfig.compilerOptions.outDir : undefined);
    for (const file of files) {
        commands.push(new command_1.CopyCommand(path_1.resolve(cwd), path_1.resolve(cwd, 'dist'), file));
    }
    runCommands(commands).then(() => {
        console.log('> Finished All Commands');
        if (tsconfig && tsconfig.compilerOptions && tsconfig.compilerOptions.outDir) {
            console.log(`> Copying and fixing package.json into ${tsconfig.compilerOptions.outDir}`);
            packageJson = utils_1.modifyPackageJson(packageJson, tsconfig.compilerOptions.outDir);
            console.log(`${ansi_colors_1.default.green('DONE')}`);
            fs_1.default.writeFileSync(path_1.resolve(tsconfig.compilerOptions.outDir, 'package.json'), JSON.stringify(packageJson, null, 2));
        }
        if (commander_1.default.dryRun) {
            console.log();
            console.log(`> ${ansi_colors_1.default.yellow('Dry-run enabled, not running npm-publish')}`);
        }
        else {
            const child = child_process_1.spawnSync('npm', ['publish'], {
                cwd: path_1.resolve(cwd, 'dist'),
                stdio: 'inherit'
            });
            console.log();
            if (child.status !== 0) {
                console.log(`> ${ansi_colors_1.default.red('ERR')} Failed to run npm publish, please review the output above.`);
            }
            else {
                console.log(`> ${ansi_colors_1.default.green('PUBLISHED')}`);
            }
        }
    }).catch((err) => {
        console.log();
        console.error(`${err.message}.`);
    });
}
commander_1.default.version('0.5.2');
commander_1.default
    .option('--dryrun, --dry-run', 'Do a dry-run of tsc-publish without publishing')
    .option('--postinstall, --post-install', 'Run post-install step for tsc-publish')
    .option('--no-checks', 'Will not run lint or test steps');
commander_1.default.parse(process.argv);
let cwd = process.cwd();
while (!fs_1.default.existsSync(path_1.resolve(cwd, 'package.json'))) {
    if (cwd === path_1.resolve(cwd, '..')) {
        throw new Error("Could not find package.json file");
    }
    cwd = path_1.resolve(cwd, '..');
}
const packagePath = path_1.resolve(cwd, 'package.json');
let packageJson = undefined;
try {
    packageJson = JSON.parse(strip_json_comments_1.default(fs_1.default.readFileSync(packagePath, { encoding: 'utf8' })));
}
catch (exc) {
    console.error('Failed to parse package.json file');
    process.exit(1);
}
let tsconfig = undefined;
try {
    tsconfig = utils_1.parseTsConfig(path_1.resolve(cwd, 'tsconfig.json'));
}
catch (exc) {
    console.error('Failed to parse tsconfig.json file');
    process.exit(1);
}
if (packageJson && tsconfig) {
    runner(cwd, packagePath, packageJson, tsconfig);
}
else {
    console.error('Failed to load package.json or tsconfig.json');
    process.exit(1);
}
//# sourceMappingURL=index.js.map