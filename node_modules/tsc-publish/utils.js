"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = __importDefault(require("fs"));
const ignore_walk_1 = __importDefault(require("ignore-walk"));
const strip_json_comments_1 = __importDefault(require("strip-json-comments"));
const IGNORED_FILES = ['.DS_Store', '.npmrc', 'npm-debug.log', 'config.gypi', '.gitignore', 'package.json', 'package-lock.json', '.DS_Store'];
const AUTO_INCLUDE_FILES = ['README', 'LICENSE', 'LICENCE', 'CHANGELOG'];
function stripLeadingSlash(string) {
    return string.replace(/^\.?\//, '');
}
exports.stripLeadingSlash = stripLeadingSlash;
function replaceString(string, outDir) {
    return stripLeadingSlash(stripLeadingSlash(string).replace(stripLeadingSlash(outDir), ''));
}
exports.replaceString = replaceString;
function modifyPackageJson(packageJson, outDir) {
    outDir = outDir.replace(/^\.\//, '');
    if (packageJson.main) {
        packageJson.main = replaceString(packageJson.main, outDir);
    }
    if (packageJson.types) {
        packageJson.types = replaceString(packageJson.types, outDir);
    }
    if (packageJson.bin) {
        for (const key in packageJson.bin) {
            packageJson.bin[key] = replaceString(packageJson.bin[key], outDir);
        }
    }
    // Remove block for running npm publish
    if (packageJson.scripts) {
        delete packageJson.scripts['prepublishOnly'];
    }
    delete packageJson.devDependencies;
    return packageJson;
}
exports.modifyPackageJson = modifyPackageJson;
function shouldIncludeFile(entry, outDir) {
    return (entry.substring(0, 5) !== '.git/'
        && entry.substring(0, 4) !== '.hg/'
        && entry.substring(0, 13) !== 'node_modules/'
        && (outDir === '' || entry.substring(0, outDir.length) !== outDir)
        && !(IGNORED_FILES.includes(entry)));
}
exports.shouldIncludeFile = shouldIncludeFile;
/**
 * Gets list of files to include in the build folder.
 *
 * List of files will include files not ignored by .npmignore (if exists)
 * and always README, LICEN[CS]E, and CHANGELOG (if they exist).
 *
 * @param path path of directory to get files out of
 */
function getNonSrcFiles(path, outDir) {
    const files = new Set();
    const strippedOutDir = stripLeadingSlash(outDir || '');
    if (fs_1.default.existsSync(path_1.join(path, '.npmignore'))) {
        const includeFiles = ignore_walk_1.default.sync({ path: path, ignoreFiles: ['.npmignore'] }).filter((entry) => {
            return shouldIncludeFile(entry, strippedOutDir);
        });
        includeFiles.forEach((entry) => files.add(entry));
    }
    for (const file of fs_1.default.readdirSync(path)) {
        const filePath = path_1.resolve(path, file);
        if (fs_1.default.lstatSync(filePath).isDirectory()) {
            continue;
        }
        if (AUTO_INCLUDE_FILES.includes(path_1.basename(filePath, path_1.extname(filePath)).toUpperCase())) {
            files.add(file);
        }
    }
    return Array.from(files);
}
exports.getNonSrcFiles = getNonSrcFiles;
/**
 * Function to load the tsconfig.json file, which allows for both comments as well
 * as for trailing commas.
 * @param path
 */
function parseTsConfig(path) {
    const trailingCommaRegex = /,(?=\s*?[}\]])/g;
    return JSON.parse(strip_json_comments_1.default(fs_1.default.readFileSync(path, { encoding: 'utf8' })).replace(trailingCommaRegex, ''));
}
exports.parseTsConfig = parseTsConfig;
//# sourceMappingURL=utils.js.map