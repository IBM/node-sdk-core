{"version":3,"sources":["../../src/rules/tagLines.js"],"names":["context","jsdoc","utils","alwaysNever","count","noEndLines","options","tags","some","tg","tagIdx","source","tokens","tag","name","type","description","end","idx","fixer","removeTagItem","reportJSDoc","line","number","slice","lines","forEach","push","length","addLines","iterateAllJsdocs","meta","docs","url","fixable","schema","enum","additionalProperies","properties"],"mappings":"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","sourcesContent":["import iterateJsdoc from '../iterateJsdoc';\n\nexport default iterateJsdoc(({\n  context,\n  jsdoc,\n  utils,\n}) => {\n  const [\n    alwaysNever = 'never',\n    {\n      count = 1,\n      noEndLines = false,\n    } = {},\n  ] = context.options;\n\n  if (alwaysNever === 'never') {\n    jsdoc.tags.some((tg, tagIdx) => {\n      return tg.source.some(({tokens: {tag, name, type, description, end}}, idx) => {\n        const fixer = () => {\n          utils.removeTagItem(tagIdx, idx);\n        };\n        if (!tag && !name && !type && !description && !end) {\n          utils.reportJSDoc(\n            'Expected no lines between tags',\n            {line: tg.source[0].number + 1},\n            fixer,\n            true,\n          );\n\n          return true;\n        }\n\n        return false;\n      });\n    });\n\n    return;\n  }\n\n  (noEndLines ? jsdoc.tags.slice(0, -1) : jsdoc.tags).some((tg, tagIdx) => {\n    const lines = [];\n\n    tg.source.forEach(({number, tokens: {tag, name, type, description, end}}, idx) => {\n      if (!tag && !name && !type && !description && !end) {\n        lines.push({idx, number});\n      }\n    });\n    if (lines.length < count) {\n      const fixer = () => {\n        utils.addLines(tagIdx, lines[lines.length - 1]?.idx || 1, count - lines.length);\n      };\n      utils.reportJSDoc(\n        `Expected ${count} line${count === 1 ? '' : 's'} between tags but found ${lines.length}`,\n        {line: lines[lines.length - 1]?.number || tg.source[0].number},\n        fixer,\n        true,\n      );\n\n      return true;\n    }\n\n    return false;\n  });\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Enforces lines (or no lines) between tags.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc#eslint-plugin-jsdoc-rules-tag-lines',\n    },\n    fixable: 'code',\n    schema: [\n      {\n        enum: ['always', 'never'],\n        type: 'string',\n      },\n      {\n        additionalProperies: false,\n        properties: {\n          count: {\n            type: 'integer',\n          },\n          noEndLines: {\n            type: 'boolean',\n          },\n        },\n        type: 'object',\n      },\n    ],\n    type: 'suggestion',\n  },\n});\n"],"file":"tagLines.js"}