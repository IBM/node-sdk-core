(function() {
  var ExecutedModulesFinder, ModuleNameParser, Promise, _, coroutine, fsExtra, glob, path, readFile, readJson,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  fsExtra = require('fs-extra');

  ModuleNameParser = require('./module_name_parser');

  path = require('path');

  Promise = require('bluebird');

  coroutine = Promise.coroutine;

  glob = Promise.promisify(require('glob'));

  readFile = Promise.promisify(fsExtra.readFile);

  readJson = Promise.promisify(fsExtra.readJson);

  ExecutedModulesFinder = (function() {
    function ExecutedModulesFinder(arg) {
      this.shellScripts = arg.shellScripts;
      this.findModuleExecutableUsage = bind(this.findModuleExecutableUsage, this);
    }

    ExecutedModulesFinder.prototype.find = coroutine(function*(arg) {
      var dir, moduleExecutables, packageJson, packageJsonScripts, ref, shellScripts;
      dir = arg.dir, packageJson = arg.packageJson;
      ref = (yield Promise.all([this.getModuleExecutables(dir), this.readShellScripts(dir)])), moduleExecutables = ref[0], shellScripts = ref[1];
      packageJsonScripts = packageJson.scripts || {};
      return this.findModuleExecutableUsage({
        moduleExecutables: moduleExecutables,
        packageJsonScripts: packageJsonScripts,
        shellScripts: shellScripts
      });
    });

    ExecutedModulesFinder.prototype.findInScript = function(script, moduleExecutables) {
      var executable, executables, i, len, name, result;
      result = [];
      for (name in moduleExecutables) {
        executables = moduleExecutables[name];
        for (i = 0, len = executables.length; i < len; i++) {
          executable = executables[i];
          if (ModuleNameParser.isGlobalExecutable(executable)) {
            continue;
          }
          if (script.match("\\b" + executable + "\\b") && indexOf.call(result, name) < 0) {
            result.push(name);
          }
        }
      }
      return result;
    };

    ExecutedModulesFinder.prototype.findModuleExecutableUsage = function(arg) {
      var fileContent, filePath, i, j, len, len1, moduleExecutables, moduleName, packageJsonScripts, ref, ref1, result, script, scriptName, shellScripts;
      moduleExecutables = arg.moduleExecutables, packageJsonScripts = arg.packageJsonScripts, shellScripts = arg.shellScripts;
      result = [];
      for (scriptName in packageJsonScripts) {
        script = packageJsonScripts[scriptName];
        ref = this.findInScript(script, moduleExecutables);
        for (i = 0, len = ref.length; i < len; i++) {
          moduleName = ref[i];
          result.push({
            name: moduleName,
            script: scriptName
          });
        }
      }
      for (filePath in shellScripts) {
        fileContent = shellScripts[filePath];
        ref1 = this.findInScript(fileContent, moduleExecutables);
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          moduleName = ref1[j];
          result.push({
            name: moduleName,
            file: filePath
          });
        }
      }
      return result;
    };

    ExecutedModulesFinder.prototype.getModuleExecutables = coroutine(function*(dir) {
      var files, nodeModulesPath;
      nodeModulesPath = path.join(dir, 'node_modules');
      files = (yield glob(nodeModulesPath + "/{*,*/*}/package.json"));
      return _.fromPairs((yield Promise.map(files, this.getModuleExecutablesPair)));
    });

    ExecutedModulesFinder.prototype.getModuleExecutablesPair = coroutine(function*(packageJsonPath) {
      var executables, packageJson;
      packageJson = (yield readJson(packageJsonPath));
      executables = _.isString(packageJson.bin) ? [packageJson.name] : _.isObject(packageJson.bin) ? _.keys(packageJson.bin) : [];
      return [packageJson.name, executables];
    });

    ExecutedModulesFinder.prototype.readShellScripts = coroutine(function*(dir, done) {
      var fileMapping, filePaths;
      filePaths = (yield glob(this.shellScripts.root, {
        cwd: dir,
        ignore: this.shellScripts.ignore
      }));
      fileMapping = _.fromPairs(filePaths.map(function(filePath) {
        var fileContentPromise;
        fileContentPromise = readFile(path.join(dir, filePath), 'utf8');
        return [filePath, fileContentPromise];
      }));
      return (yield Promise.props(fileMapping));
    });

    return ExecutedModulesFinder;

  })();

  module.exports = ExecutedModulesFinder;

}).call(this);
