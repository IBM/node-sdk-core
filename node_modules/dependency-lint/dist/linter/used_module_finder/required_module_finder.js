(function() {
  var ModuleNameParser, Promise, RequiredModuleFinder, _, coroutine, detective, glob, path, prependToError, readFile;

  _ = require('lodash');

  detective = require('detective');

  ModuleNameParser = require('./module_name_parser');

  path = require('path');

  prependToError = require('../../util/prepend_to_error');

  Promise = require('bluebird');

  coroutine = Promise.coroutine;

  glob = Promise.promisify(require('glob'));

  readFile = Promise.promisify(require('fs').readFile);

  RequiredModuleFinder = (function() {
    function RequiredModuleFinder(arg) {
      this.acornParseProps = arg.acornParseProps, this.files = arg.files, this.stripLoaders = arg.stripLoaders, this.transpilers = arg.transpilers;
    }

    RequiredModuleFinder.prototype.find = coroutine(function*(dir) {
      var files, results;
      files = (yield glob(this.files.root, {
        cwd: dir,
        ignore: this.files.ignore
      }));
      results = (yield Promise.map(files, (function(_this) {
        return function(filePath) {
          return _this.findInFile({
            dir: dir,
            filePath: filePath
          });
        };
      })(this)));
      return _.flatten(results);
    });

    RequiredModuleFinder.prototype.findInFile = coroutine(function*(arg) {
      var content, dir, err, filePath, moduleNames;
      dir = arg.dir, filePath = arg.filePath;
      content = (yield readFile(path.join(dir, filePath), 'utf8'));
      try {
        content = this.compileIfNeeded({
          content: content,
          dir: dir,
          filePath: filePath
        });
        moduleNames = detective(content, {
          parse: this.acornParseProps,
          isRequire: this.isRequire
        });
      } catch (error) {
        err = error;
        throw prependToError(err, filePath);
      }
      return moduleNames = this.normalizeModuleNames({
        filePath: filePath,
        moduleNames: moduleNames
      });
    });

    RequiredModuleFinder.prototype.compileIfNeeded = function(arg) {
      var compiler, content, dir, ext, filePath, fnName, result, transpiler;
      content = arg.content, dir = arg.dir, filePath = arg.filePath;
      ext = path.extname(filePath);
      transpiler = _.find(this.transpilers, ['extension', ext]);
      if (transpiler) {
        compiler = require(transpiler.module);
        fnName = transpiler.fnName || 'compile';
        result = compiler[fnName](content, {
          filename: path.join(dir, filePath)
        });
        if (transpiler.resultKey) {
          result = result[transpiler.resultKey];
        }
        return result;
      } else {
        return content;
      }
    };

    RequiredModuleFinder.prototype.isRequire = function(arg) {
      var callee, type;
      type = arg.type, callee = arg.callee;
      return type === 'CallExpression' && ((callee.type === 'Identifier' && callee.name === 'require') || (callee.type === 'MemberExpression' && callee.object.type === 'Identifier' && callee.object.name === 'require' && callee.property.type === 'Identifier' && callee.property.name === 'resolve'));
    };

    RequiredModuleFinder.prototype.normalizeModuleNames = function(arg) {
      var filePath, moduleNames;
      filePath = arg.filePath, moduleNames = arg.moduleNames;
      return _.chain(moduleNames).map(this.stripLoaders ? ModuleNameParser.stripLoaders : void 0).reject(ModuleNameParser.isBuiltIn).reject(ModuleNameParser.isRelative).map(ModuleNameParser.stripSubpath).map(function(name) {
        return {
          name: name,
          file: filePath
        };
      }).value();
    };

    return RequiredModuleFinder;

  })();

  module.exports = RequiredModuleFinder;

}).call(this);
